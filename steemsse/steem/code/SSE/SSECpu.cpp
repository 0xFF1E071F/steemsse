/*
*/

#include "SSE.h"

#if defined(SSE_CPU)

#include "../pch.h" // Each object should include this precompiled header
#pragma hdrstop  // Signals the end of precompilation
#include <gui.decla.h> //PeekEvent()
#include "cpu.decla.h"
#include "SSECpu.h"
#include "SSEFrameReport.h"
#if defined(DEBUG_BUILD)
extern const char*exception_action_name[4];//={"read from","write to","fetch from","instruction execution"};
#endif

#include "SSESTF.h"
#include "SSEGlue.h"
#include "SSEMMU.h"

#define LOGSECTION LOGSECTION_CPU



TM68000::TM68000() {
  Reset(true);
}


void TM68000::Reset(bool Cold) {
#if defined(SSE_DEBUG)    
  if(Cold)
    nExceptions=nInstr=0;
#endif
  tpend=false; //guess so
#if defined(SSE_CPU_E_CLOCK)
  if(Cold)
    cycles_for_eclock=cycles0=0;
#endif
}



#undef LOGSECTION
#define LOGSECTION LOGSECTION_CRASH


#if defined(SSE_CPU_E_CLOCK)
/*  
"Enable (E)
This signal is the standard enable signal common to all M6800 Family peripheral
devices. A single period of clock E consists of 10 MC68000 clock periods (six clocks
low, four clocks high). This signal is generated by an internal ring counter that may
come up in any state. (At power-on, it is impossible to guarantee phase relationship of E
to CLK.) The E signal is a free-running clock that runs regardless of the state of the
MPU bus."

  The ambition of this routine is to get correct timings
  for ACIA, HBL and VBL interrupts..
  It is based on this table by Nyh:
http://www.atari-forum.com/viewtopic.php?f=68&p=254097&sid=3f96c5838329b68260a38e4b388b4561#p254097
CPU-Clock  E-clock Keyboard read
  000000   00000.0     28
  160256   16025.6     20
  320512   32051.2     24
  480768   48076.8     20
  641024   64102.4     24
  801280   80128.0     28
  961536   96153.6     20
 1121792  112179.2     24
 1282048  128204.8     20
 1442304  144230.4     24

*/

#undef LOGSECTION
#define LOGSECTION LOGSECTION_INTERRUPTS

int TM68000::SyncEClock(int dispatcher) {
  BYTE wait_states=0;
  // sync with E max once per instruction

  if(EClock_synced) 
    return wait_states;

  EClock_synced=true; 
  UpdateCyclesForEClock();
  BYTE cycles=cycles_for_eclock%10;

  switch(cycles) {
  case 0:
    wait_states=8;
#if defined(SSE_INT_HBL_E_CLOCK_HACK_382) 
    if(MMU.WS[OPTION_WS]==1 && ST_TYPE==STF && dispatcher==ECLOCK_HBL 
      && OPTION_HACKS)
     wait_states-=2;// hack Closure, 3615GEN4, as STF WS1
#endif
    break;
  case 2:
  case 4: 
    wait_states=4;
    break;
  default: //6,8
    wait_states=0;
  }//sw
 // TRACE_OSD("%d %d",act,wait_states);
 
#if defined(SSE_BOILER) 
#if defined(SSE_BOILER_FRAME_REPORT_392)
  char cdispatcher[4]="VHA";
#else
  char* sdispatcher[]={"VBL","HBL","ACIA"};
#endif
#if defined(SSE_BOILER_FRAME_REPORT) && defined(SSE_BOILER_FRAME_REPORT_MASK)
  if(FRAME_REPORT_MASK2 & FRAME_REPORT_MASK_INT)
#if defined(SSE_BOILER_FRAME_REPORT_392) //even if it's generally obvious
  {
    char string[3];
    sprintf(string,"E%c",cdispatcher[dispatcher]);
    FrameEvents.Add(scan_y,LINECYCLES,string,wait_states);
  }
#else
    FrameEvents.Add(scan_y,LINECYCLES,'E',wait_states);
#endif
#endif
#if defined(SSE_BOILER_TRACE_CONTROL)
  if(wait_states && (TRACE_MASK2&TRACE_CONTROL_ECLOCK)) 
#if defined(SSE_CPU_E_CLOCK)
#if defined(SSE_BOILER_FRAME_REPORT_392)
    TRACE_LOG("F%d y%d c%d %c E-Clock +%d\n",TIMING_INFO,cdispatcher[dispatcher],wait_states);
#else
    TRACE_LOG("F%d y%d c%d %s E-Clock +%d\n",TIMING_INFO,sdispatcher[dispatcher],wait_states);
#endif
#else
    TRACE_LOG("F%d y%d c%d E-Clock +%d\n",TIMING_INFO,wait_states);
#endif
#endif
#endif//dbg
  LastEClockCycles[dispatcher]=wait_states;
  return wait_states;
}

/*  We come here at each VBL and each time the e-clock is read,
    so cycles_for_eclock should never overflow or go negative.
*/
void TM68000::UpdateCyclesForEClock() {
  COUNTER_VAR cycles1=ACT; // current CPU cycles (can be negative)
  COUNTER_VAR ncycles=cycles1-cycles0; // elapsed CPU cycles since last refresh
  cycles_for_eclock+=ncycles; // update counter for E-clock
  cycles_for_eclock%=(10*16); // remove high bits
  cycles0=cycles1; // record current CPU cycles
}

#undef LOGSECTION

#endif//E-clock

TM68000 M68000; // singleton

#endif//#if defined(SSE_CPU)

