Shifter

Steem SSE development notes mostly based on ijor's insights.
This replaces my former ramblings (my parts marked by SS - ignore them!).

The Shifter has two internal 4bit counters:

pixel counter 
init to 4 at borders so that it won't overwrap during a LOAD signal

LOAD counter 
4bit but works by shifting a 1, so it counts 1-4 then it
is reset by Shifter internal Reload
This corresponds to our Shifter.Preload variable

Reload pulse
reload of the shift registers (IR => RR)
It happens when LOAD counter = 4 and pixel counter = 16
timing: 1 pixel


DE

DE has a single task inside Shifter. It keeps the 4-bit pixel counter disabled
at the borders. Nothing else at all.

But the 4-bit counter is not enabled synchronously to the DE edge. It is
enabled at the LOAD pulse. 
DE performs just a mask of the LOAD pulse. 
The counter is enabled at the first LOAD pulse. 
It doesn't matter if DE was raised half cycle, one or several cycles before
the LOAD pulse.

[SS]
In particular, DE doesn't command actual shifting and display.

The Shifter doesn't display as soon as DE is asserted. At the start of a line,
it is empty. First its registers must be filled.
The four input registers are filled before shifting starts, in all resolutions.
So if DE starts at 6 (HIRES), effective shifting will start after prefetch
(16 cycles), plus some latency (8 cycles): 6+16+8, at cycle 30.
If shifting started earlier, it would be before HBLANK is turned off on a 
colour screen , at cycle 28, and part of the overscan picture would be
invisible, which isn't the case. 
If this was different on the STE, the overscan pictures would be different,
which isn't the case.
[/SS]

Palette

Palette lookup is rather simple and straightforward. The output of the Shift
matrix is decoded and this generates enables signals to the palette registers.
The output of one, and only one, register is enabled, all the others are
disabled. And this is synchronous to the pixel clock.


SHIFTER-MMU wakestates

Shifter wakestates affect the relation between writes to Shifter and Shifter
pixel clock. 
Palette lookup isn't really affected, this is synchronous to the pixel clock.
What is affected is when exactly the palette register is changed.

The palette registers are asynchronous transparent latches. 
This means that the output changes as soon as latching (writing) is enabled. 
This is contrary to a synchronous flip flop that doesn't change its output 
until actually latching and writing ended.

Because of this the output of a latch might glitch, or might even be completely
 wrong at the start of the write cycle. Conceivable, its input might be not 
ready at all at that point. So it might output garbage, or zero, at the 
beginning of the write cycle.

As long as you ignore the output of the latch until it's stable, which should
happen by the end of the write cycle in the worst case, then everything is
fine. But if you read the output of the latch with a flip flop clocked 
independently, then this might be clocked too early, before the latch output 
is ready and stable.

The full analysis here is complicated. But I can start to see the scenario 
where the palette latch momentarily outputs garbage, or zero, or whatever 
was left on the internal data input latch (a previous write, the last screen
memory load ...). And it depends on the exact relation between the write cycle
and the pixel clock (including, but not only, the SHIFTER wakestate), if the
RGB flip flops capture the output of the latches when they become ready and 
stable or not!


[SS]
Still don't understand:
why the right-off 2 extra words have no effect, but when you destabilise as 
in the bee demos, the 2 extra words do have effect (shift planes and pixels)
[/SS]

